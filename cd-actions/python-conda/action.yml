name: Python Conda Builder
description: Build Python packages using conda/mamba

inputs:
  name:
    description: 'Build name for artifacts'
    required: true
  config:
    description: 'Build configuration JSON'
    required: true
  ref_name:
    description: 'Git ref name for artifacts'
    required: true
  python_version:
    description: 'Python version override'
    required: false
  dry_run:
    description: 'Dry run mode'
    required: false
    default: 'false'
  gh_pat:
    description: 'GitHub PAT token'
    required: false
  nexus_url:
    description: 'Nexus conda repository URL'
    required: false
    default: 'https://nexus-test.ecmwf.int/repository/conda-ecmwf-public'
  nexus_token:
    description: 'Nexus upload token'
    required: false
  skip_installation_test:
    description: 'Skip testing package installation from Nexus'
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Parse build configuration
      id: config
      shell: bash
      run: |
        python3 <<'PY'
        import json
        import os
        import sys

        raw = '''${{ inputs.config }}'''.strip()
        print(f"Raw config: {raw}")
        try:
            cfg = json.loads(raw)
        except json.JSONDecodeError as e:
            print(f"Failed to parse JSON config: {e}")
            sys.exit(1)

        run_id = os.environ.get('GITHUB_RUN_ID', '')

        remote_repo = cfg.get('remote_repo', '') or ''
        remote_ref = cfg.get('remote_ref', 'main') or 'main'
        remote_path = cfg.get('remote_path', '.conda') or '.conda'

        conda_dir = f".conda-{run_id}" if remote_repo else ".conda"

        channels_list = cfg.get('channels') or ["conda-forge"]
        if not isinstance(channels_list, list):
            channels_list = [str(channels_list)]
        channels = " ".join([c for c in channels_list if c]) or "conda-forge"

        conda_build_args = cfg.get('conda_build_args', '--no-anaconda-upload') or '--no-anaconda-upload'

        meta_file = f"{conda_dir}/meta.yaml"
        output_folder = f"{conda_dir}/build"
        artifact_pattern = f"{output_folder}/**/*.tar.bz2"

        outputs = {
            'conda_dir': conda_dir,
            'meta_file': meta_file,
            'channels': channels,
            'output_folder': output_folder,
            'artifact_pattern': artifact_pattern,
            'conda_build_args': conda_build_args,
            'remote_repo': remote_repo,
            'remote_ref': remote_ref,
            'remote_path': remote_path,
        }

        with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
            for k, v in outputs.items():
                fh.write(f"{k}={v}\n")
                print(f"Set output {k}={v}")
        PY
        
    - name: Fetch remote conda configuration
      if: ${{ steps.config.outputs.remote_repo != '' }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh_pat || github.token }}
      run: |
        remote_repo="${{ steps.config.outputs.remote_repo }}"
        remote_ref="${{ steps.config.outputs.remote_ref }}"
        remote_path="${{ steps.config.outputs.remote_path }}"
        
        echo "Fetching conda configuration from remote repository:"
        echo "  Repository: $remote_repo"
        echo "  Reference: $remote_ref"
        echo "  Path: $remote_path"
        
        # Create temporary directory for remote checkout
        temp_dir=$(mktemp -d)
        echo "Created temporary directory: $temp_dir"
        
        # Clone the remote repository using standard git commands
        # Format the repository URL with token authentication
        if [[ "$remote_repo" == *"/"* ]] && [[ "$remote_repo" != http* ]]; then
            # Assume GitHub format: owner/repo
            repo_url="https://x-access-token:${GH_TOKEN}@github.com/${remote_repo}.git"
        else
            # Full URL provided - insert token if it's an HTTPS GitHub URL
            if [[ "$remote_repo" == https://github.com/* ]]; then
                repo_url="${remote_repo/https:\/\/github.com\//https://x-access-token:${GH_TOKEN}@github.com/}"
                if [[ "$repo_url" != *.git ]]; then
                    repo_url="${repo_url}.git"
                fi
            else
                repo_url="$remote_repo"
            fi
        fi
        
        echo "Cloning repository: $repo_url"
        git clone --depth 1 --branch "$remote_ref" "$repo_url" "$temp_dir"
        
        # Create local conda directory if it doesn't exist
        mkdir -p ${{ steps.config.outputs.conda_dir }}
        
        # Copy conda configuration files from remote repository
        if [[ -d "$temp_dir/$remote_path" ]]; then
            echo "Copying files from $temp_dir/$remote_path to ${{ steps.config.outputs.conda_dir }}"
            cp -r "$temp_dir/$remote_path"/* ${{ steps.config.outputs.conda_dir }}
        else
            echo "Remote path $remote_path not found in repository"
            exit 1
        fi
        
        # Clean up temporary directory
        rm -rf "$temp_dir"
        echo "Remote conda configuration fetched successfully"
        
    - name: Validate configuration files
      id: validate
      shell: bash
      run: |
        meta_file="${{ steps.config.outputs.meta_file }}"
        
        if [[ ! -f "$meta_file" ]]; then
            echo "Meta file not found: $meta_file"
            exit 1
        fi
        
        echo "meta_dir=$(dirname $meta_file)" >> $GITHUB_OUTPUT
        echo "Configuration files validated successfully"

    - name: Setup conda env dir
      shell: bash
      run: |
        echo "CONDA_ENVS_DIRS=$RUNNER_TEMP/envs" >> "$GITHUB_ENV"
        mkdir -p "$RUNNER_TEMP/envs"

    - name: Create conda environment
      shell: bash -el {0}
      run: |
        BUILD_ENV="build-env-${GITHUB_RUN_ID}"
        echo "BUILD_ENV=$BUILD_ENV" >> "$GITHUB_ENV"
        mamba env create -n "$BUILD_ENV"
          
    - name: Install build dependencies
      shell: bash -el {0}
      run: |
        eval "$(conda shell.bash hook)"
        conda activate "$BUILD_ENV"
        mamba install -y conda conda-build boa conda-verify
        mamba info
        mamba list
        
    - name: Build conda package
      shell: bash -el {0}
      run: |
        eval "$(conda shell.bash hook)"
        conda activate "$BUILD_ENV"
        meta_dir="${{ steps.validate.outputs.meta_dir }}"
        output_folder="${{ steps.config.outputs.output_folder }}"
        build_args="${{ steps.config.outputs.conda_build_args }}"

        echo "Building conda package from: $meta_dir"
        echo "Output folder: $output_folder"
        echo "Build args: $build_args"

        mkdir -p "$output_folder"

        conda mambabuild "$meta_dir" -c https://nexus-test.ecmwf.int/repository/conda-ecmwf-public/ -c https://nexus.ecmwf.int/repository/conda-forge/ --output-folder "$output_folder" $build_args
        
    - name: List built packages
      shell: bash -el {0}
      run: |
        output_folder="${{ steps.config.outputs.output_folder }}"
        echo "Built packages:"
        find "$output_folder" -name "*.tar.bz2" -o -name "*.tar.bz2" | sort
        
    - name: Verify artifacts
      shell: bash -el {0}
      run: |
        output_folder="${{ steps.config.outputs.output_folder }}"
        echo "Checking for conda packages in: $output_folder"

        # Check if conda packages exist in output folder
        if ! find "$output_folder" -name "*.tar.bz2" -type f | head -1 | grep -q .; then
            echo "No conda packages found in: $output_folder"
            echo "Available files:"
            find "$output_folder" -type f | head -20
            exit 1
        fi

    - name: Upload to Nexus
      if: ${{ inputs.dry_run != 'true' }}
      shell: bash
      run: |
        output_folder="${{ steps.config.outputs.output_folder }}"
        nexus_url="${{ inputs.nexus_url }}"

        echo "Uploading conda packages to Nexus: $nexus_url"

        # Find all built packages
        packages=$(find "$output_folder" -name "*.tar.bz2" -type f)

        if [ -z "$packages" ]; then
            echo "No packages found to upload"
            exit 1
        fi

        # Download channeldata.json
        index_temp_dir=$(mktemp -d)
        echo "Downloading current channeldata from $nexus_url/channeldata.json"
        if curl -sf -u "${{ inputs.nexus_token }}" \
            "$nexus_url/channeldata.json" \
            -o "$index_temp_dir/channeldata.json"; then
            echo "Downloaded existing channeldata.json"
        else
            echo "No existing channeldata.json found (will create new)"
        fi

        # Process each package
        for package in $packages; do
            echo "Processing package: $package"

            # Detect subdir from path
            subdir=$(basename $(dirname "$package"))
            package_name=$(basename "$package")

            echo "  Subdir: $subdir"
            echo "  Package: $package_name"

            # Create subdir directory for index operations
            mkdir -p "$index_temp_dir/$subdir"

            # Download current repodata.json
            echo "  Downloading current index from $nexus_url/$subdir/repodata.json"
            if curl -sf -u "${{ inputs.nexus_token }}" \
                "$nexus_url/$subdir/repodata.json" \
                -o "$index_temp_dir/$subdir/repodata.json"; then
                echo "  Downloaded existing repodata.json"
            else
                echo "  No existing repodata.json found (will create new)"
            fi

            # Update the index with the new package
            echo "  Updating conda index..."

            # Setup uv venv
            echo "  Setting up Python venv for index update..."
            uv venv "$RUNNER_TEMP/update-index-venv"
            source "$RUNNER_TEMP/update-index-venv/bin/activate"
            uv pip install packaging

            uv run python "${{ github.action_path }}/scripts/update_conda_index.py" \
                "$package" \
                --repodata-dir "$index_temp_dir" \
                --subdir "$subdir" \
                --output-dir "$index_temp_dir"

            # Upload the package
            echo "  Uploading package to $nexus_url/$subdir/$package_name"
            if ! curl -f -u "${{ inputs.nexus_token }}" \
                --upload-file "$package" \
                "$nexus_url/$subdir/$package_name"; then
                echo "  Error: Failed to upload package"
                rm -rf "$index_temp_dir"
                exit 1
            fi
            echo "  Package uploaded successfully"

            # Upload updated repodata.json
            echo "  Uploading updated repodata.json"
            if ! curl -f -u "${{ inputs.nexus_token }}" \
                --upload-file "$index_temp_dir/$subdir/repodata.json" \
                "$nexus_url/$subdir/repodata.json"; then
                echo "  Error: Failed to upload repodata.json"
                rm -rf "$index_temp_dir"
                exit 1
            fi

            # Upload repodata_from_packages.json
            echo "  Uploading repodata_from_packages.json"
            if ! curl -f -u "${{ inputs.nexus_token }}" \
                --upload-file "$index_temp_dir/$subdir/repodata_from_packages.json" \
                "$nexus_url/$subdir/repodata_from_packages.json"; then
                echo "  Error: Failed to upload repodata_from_packages.json"
                rm -rf "$index_temp_dir"
                exit 1
            fi

            echo "  Index files uploaded successfully"

            echo "✓ Successfully uploaded $package_name to Nexus"
        done

        # Upload channeldata.json
        echo ""
        echo "Uploading updated channeldata.json"
        if ! curl -f -u "${{ inputs.nexus_token }}" \
            --upload-file "$index_temp_dir/channeldata.json" \
            "$nexus_url/channeldata.json"; then
            echo "Error: Failed to upload channeldata.json"
            rm -rf "$index_temp_dir"
            exit 1
        fi
        echo "✓ Channeldata uploaded successfully"

        # Clean up
        rm -rf "$index_temp_dir"

        echo ""
        echo "All packages and indexes uploaded to Nexus successfully!"

    - name: Test package installation from Nexus
      if: ${{ inputs.dry_run != 'true' && inputs.skip_installation_test != 'true' }}
      shell: bash -el {0}
      run: |
        output_folder="${{ steps.config.outputs.output_folder }}"
        nexus_url="${{ inputs.nexus_url }}"

        echo "Testing package installation from Nexus..."

        # Get package name and version from built packages
        packages=$(find "$output_folder" -name "*.tar.bz2" -type f)

        for package in $packages; do
            package_name=$(basename "$package")
            echo ""
            echo "Testing installation of: $package_name"

            # Extract package name without version/build info
            pkg_base=$(echo "$package_name" | sed 's/-.*//')

            # Create a test environment
            test_env="test-install-${GITHUB_RUN_ID}-${RANDOM}"
            echo "Creating test environment: $test_env"

            eval "$(conda shell.bash hook)"

            # Create environment and install package from Nexus
            if mamba create -n "$test_env" -c "$nexus_url" -c conda-forge "$pkg_base" -y; then
                echo "✓ Successfully installed $pkg_base from Nexus"

                # Verify package is installed
                conda activate "$test_env"
                if conda list | grep -q "$pkg_base"; then
                    echo "✓ Package $pkg_base verified in environment"
                else
                    echo "✗ Package $pkg_base not found in environment"
                    conda deactivate
                    conda env remove -n "$test_env" -y
                    exit 1
                fi
                conda deactivate

                # Clean up test environment
                conda env remove -n "$test_env" -y
                echo "Test environment removed"
            else
                echo "✗ Failed to install $pkg_base from Nexus"
                exit 1
            fi
        done

        echo ""
        echo "All packages successfully installed from Nexus!"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.ref_name }}-${{ inputs.name }}
        path: ${{ steps.config.outputs.artifact_pattern }}
        if-no-files-found: error
        retention-days: 90
        
    - name: Summary
      shell: bash -el {0}
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Name**: ${{ inputs.name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Meta File**: ${{ steps.config.outputs.meta_file }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Channels**: ${{ steps.config.outputs.channels }}" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "- **Mode**: Dry Run (no artifacts uploaded)" >> $GITHUB_STEP_SUMMARY
        fi