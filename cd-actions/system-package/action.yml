name: System Package Builder
description: Build DEB/RPM system packages using CMake/CPack

inputs:
  name:
    description: 'Build name for artifacts'
    required: true
  ref_name:
    description: 'Git ref name for artifacts'
    required: true
  dry_run:
    description: 'Dry run mode - build only, no uploads'
    required: false
    default: 'false'
  skip_version_check:
    description: 'Skip tag-vs-VERSION validation'
    required: false
    default: 'false'
  dependencies:
    description: 'List of dependency repositories to build (e.g. owner/repo@ref, one per line)'
    required: false
    default: ''
  dependency_branch:
    description: 'Default branch/tag for dependency repositories'
    required: false
    default: ''
  cmake_options:
    description: 'CMake options for the current repository build (-DVAR=value ...)'
    required: false
    default: ''
  ctest_options:
    description: 'CTest options for the current repository tests (-R regex ...)'
    required: false
    default: ''
  dependency_cmake_options:
    description: 'CMake options for dependency builds (owner/repo: "-DVAR=value")'
    required: false
    default: ''
  cmake:
    description: 'Use CMake instead of ecbuild for build configuration'
    required: false
    default: 'false'
  ecbundle:
    description: 'Use ecbundle for building bundles'
    required: false
    default: 'false'
  self_build:
    description: 'Whether to build from currently checked out repository'
    required: false
    default: 'true'
  self_coverage:
    description: 'Whether to collect code coverage'
    required: false
    default: 'false'
  cache_suffix:
    description: 'String appended to cache key to invalidate build cache'
    required: false
    default: ''
  toolchain_file:
    description: 'Path to CMake toolchain file'
    required: false
    default: ''
  install_dir:
    description: 'Directory for installing dependencies and current package'
    required: false
    default: ''
  download_dir:
    description: 'Directory for downloading dependency repositories and artifacts'
    required: false
    default: ''
  parallelism_factor:
    description: 'Number of threads for build job'
    required: false
    default: '2'
  cpack_generator:
    description: 'CPack generator (DEB or RPM)'
    required: true
  cpack_options:
    description: 'Pre-merged CPack options string'
    required: false
    default: ''
  package_deps:
    description: 'Runtime package dependencies (comma-separated). Translated to CPACK_DEBIAN_PACKAGE_DEPENDS or CPACK_RPM_PACKAGE_REQUIRES.'
    required: false
    default: ''
  os:
    description: 'Platform OS identifier (e.g. debian-12, rocky-9.5)'
    required: true
  compiler:
    description: 'Compiler family (e.g. gnu)'
    required: false
    default: 'gnu'
  compiler_cc:
    description: 'C compiler command'
    required: false
    default: 'gcc'
  compiler_cxx:
    description: 'C++ compiler command'
    required: false
    default: 'g++'
  compiler_fc:
    description: 'Fortran compiler command'
    required: false
    default: 'gfortran'
  gh_pat:
    description: 'GitHub PAT for repo access'
    required: false
  nexus_token:
    description: 'Nexus credential (user:token)'
    required: false
  nexus_url:
    description: 'Nexus upload URL'
    required: false

outputs:
  package_path:
    description: 'Absolute path to generated package'
    value: ${{ steps.build.outputs.package_path }}

runs:
  using: composite
  steps:
    - name: Parse build configuration
      id: config
      shell: python3 {0}
      run: |
        import os

        cpack_generator = '${{ inputs.cpack_generator }}'
        cpack_options = '${{ inputs.cpack_options }}'
        package_deps = '''${{ inputs.package_deps }}'''.strip()

        if cpack_generator == 'DEB':
            upload_method = 'multipart'
            if package_deps:
                cpack_options = f'{cpack_options} -DCPACK_DEBIAN_PACKAGE_DEPENDS="{package_deps}"'
        elif cpack_generator == 'RPM':
            upload_method = 'put'
            if package_deps:
                cpack_options = f'{cpack_options} -DCPACK_RPM_PACKAGE_REQUIRES="{package_deps}"'
        else:
            print(f"::error::Unsupported cpack_generator: {cpack_generator}")
            raise SystemExit(1)

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"upload_method={upload_method}\n")
            f.write(f"cpack_options={cpack_options}\n")

        print(f"CPack generator: {cpack_generator}")
        print(f"Upload method: {upload_method}")
        print(f"Package deps: {package_deps or '(none)'}")
        print(f"Final CPack options: {cpack_options}")

    - name: Merge build package inputs
      id: merge-inputs
      shell: python3 {0}
      run: |
        import os, yaml

        merged = {
            'repository': '${{ format('{0}@{1}', github.repository, github.sha) }}',
            'cpack_generator': '${{ inputs.cpack_generator }}',
            'cpack_options': '${{ steps.config.outputs.cpack_options }}',
            'os': '${{ inputs.os }}',
            'compiler': '${{ inputs.compiler }}',
            'compiler_cc': '${{ inputs.compiler_cc }}',
            'compiler_cxx': '${{ inputs.compiler_cxx }}',
            'compiler_fc': '${{ inputs.compiler_fc }}',
            'force_build': True,
            'recreate_cache': True,
            'save_cache': False,
            'self_test': False,
            'cmake': '${{ inputs.cmake }}',
            'ecbundle': '${{ inputs.ecbundle }}',
            'self_build': '${{ inputs.self_build }}',
            'self_coverage': '${{ inputs.self_coverage }}',
            'parallelism_factor': '${{ inputs.parallelism_factor }}',
        }

        # Add optional string fields only if non-empty.
        optional = {
            'dependencies': '''${{ inputs.dependencies }}'''.strip(),
            'dependency_branch': '''${{ inputs.dependency_branch }}'''.strip(),
            'cmake_options': '''${{ inputs.cmake_options }}'''.strip(),
            'ctest_options': '''${{ inputs.ctest_options }}'''.strip(),
            'dependency_cmake_options': '''${{ inputs.dependency_cmake_options }}'''.strip(),
            'cache_suffix': '''${{ inputs.cache_suffix }}'''.strip(),
            'toolchain_file': '''${{ inputs.toolchain_file }}'''.strip(),
            'install_dir': '''${{ inputs.install_dir }}'''.strip(),
            'download_dir': '''${{ inputs.download_dir }}'''.strip(),
        }
        for key, value in optional.items():
            if value:
                merged[key] = value

        merged_yaml = yaml.dump(merged, default_flow_style=False)

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write("build_package_inputs<<EOF\n")
            f.write(merged_yaml)
            f.write("EOF\n")

        print("Merged build_package_inputs:")
        print(merged_yaml)

    - name: Check version number
      if: ${{ inputs.skip_version_check != 'true' && inputs.dry_run != 'true' }}
      shell: python3 {0}
      run: |
        import os
        import re
        import sys

        tag = "${{ inputs.ref_name }}"

        def check_version():
            file_name = "VERSION"
            if os.path.isfile(file_name):
                with open(file_name, 'r') as f:
                    version = f.read().strip()
                    return version
            else:
                print(f"::warning::{file_name} file not found! Using {file_name} is the preferred method.")
                return

        def check_cmakelists():
            file_name = "CMakeLists.txt"
            if os.path.isfile(file_name):
                with open(file_name, 'r') as f:
                    content = f.read()
                    pattern = r"project\([\s\w]+VERSION\s+((?:\d+)(?:.\d+){0,3})"

                    hit = re.search(pattern, content)
                    version = hit.group(1)
                    return version
            else:
                print(f"::warning::{file_name} file not found!")
                return

        version = check_version() or check_cmakelists()

        if not version:
            print("::error::Version not found!")
            sys.exit(1)

        if version != tag:
            print(f"::error::Git tag ({tag}) and project version ({version}) do not match!")
            sys.exit(1)

        print("OK: Git tag and project versions match.")

    - name: Create package
      id: build
      uses: ecmwf/reusable-workflows/build-package-with-config@v2
      with:
        repository: ${{ format('{0}@{1}', github.repository, github.sha) }}
        build_package_inputs: ${{ steps.merge-inputs.outputs.build_package_inputs }}
        github_token: ${{ inputs.gh_pat || github.token }}

    - name: Verify package
      shell: bash
      run: |
        if [ -z "${{ steps.build.outputs.package_path }}" ] || [ ! -f "${{ steps.build.outputs.package_path }}" ]; then
          echo "::error::Built package not found!"
          exit 1
        fi
        echo "Package built successfully: ${{ steps.build.outputs.package_path }}"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.run_id }}-${{ inputs.name }}
        path: ${{ steps.build.outputs.package_path }}
        if-no-files-found: error
        retention-days: 90

    - name: Upload to Nexus
      if: ${{ inputs.dry_run != 'true' }}
      shell: bash
      run: |
        token="${{ inputs.nexus_token }}"
        url="${{ inputs.nexus_url }}"

        if [ -z "$token" ] || [ -z "$url" ]; then
          echo "::warning::No Nexus token or URL provided, skipping upload"
          exit 0
        fi

        package_path="${{ steps.build.outputs.package_path }}"

        if [ "${{ steps.config.outputs.upload_method }}" == "multipart" ]; then
          response=$(curl -w "%{http_code}" --user "$token" -H "Content-Type: multipart/form-data" --data-binary "@${package_path}" "$url")
        elif [ "${{ steps.config.outputs.upload_method }}" == "put" ]; then
          file_name=$(basename "$package_path")
          response=$(curl -w "%{http_code}" --user "$token" --upload-file "${package_path}" "${url}/${file_name}")
        fi

        status=$(echo "$response" | tail -c 4)
        if [ "$status" -eq 201 ] || [ "$status" -eq 200 ]; then
          echo "Successfully uploaded!"
        else
          echo "$status: Upload failed"
          exit 1
        fi
