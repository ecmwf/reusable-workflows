name: System Package Builder
description: Build DEB/RPM system packages using CMake/CPack

inputs:
  name:
    description: 'Build name for artifacts'
    required: true
  ref_name:
    description: 'Git ref name for artifacts'
    required: true
  dry_run:
    description: 'Dry run mode - build only, no uploads'
    required: false
    default: 'false'
  skip_version_check:
    description: 'Skip tag-vs-VERSION validation'
    required: false
    default: 'false'
  dependencies:
    description: 'List of dependency repositories to build (e.g. owner/repo@ref, one per line)'
    required: false
    default: ''
  dependency_branch:
    description: 'Default branch/tag for dependency repositories'
    required: false
    default: ''
  cmake_options:
    description: 'CMake options for the current repository build (-DVAR=value ...)'
    required: false
    default: ''
  ctest_options:
    description: 'CTest options for the current repository tests (-R regex ...)'
    required: false
    default: ''
  dependency_cmake_options:
    description: 'CMake options for dependency builds (owner/repo: "-DVAR=value")'
    required: false
    default: ''
  cmake:
    description: 'Use CMake instead of ecbuild for build configuration'
    required: false
    default: 'false'
  ecbundle:
    description: 'Use ecbundle for building bundles'
    required: false
    default: 'false'
  self_build:
    description: 'Whether to build from currently checked out repository'
    required: false
    default: 'true'
  self_coverage:
    description: 'Whether to collect code coverage'
    required: false
    default: 'false'
  cache_suffix:
    description: 'String appended to cache key to invalidate build cache'
    required: false
    default: ''
  toolchain_file:
    description: 'Path to CMake toolchain file'
    required: false
    default: ''
  install_dir:
    description: 'Directory for installing dependencies and current package'
    required: false
    default: ''
  download_dir:
    description: 'Directory for downloading dependency repositories and artifacts'
    required: false
    default: ''
  parallelism_factor:
    description: 'Number of threads for build job'
    required: false
    default: '2'
  cpack_generator:
    description: 'CPack generator (DEB or RPM)'
    required: true
  cpack_options:
    description: 'Pre-merged CPack options string'
    required: false
    default: ''
  package_deps:
    description: 'Runtime package dependencies (comma-separated). Translated to CPACK_DEBIAN_PACKAGE_DEPENDS or CPACK_RPM_PACKAGE_REQUIRES.'
    required: false
    default: ''
  description:
    description: 'Package description. Falls back to GitHub repository description if empty.'
    required: false
    default: ''
  license:
    description: 'Package license (SPDX identifier). Falls back to GitHub repository license if empty.'
    required: false
    default: ''
  maintainer:
    description: 'Package maintainer email (e.g. name@example.com).'
    required: false
    default: 'software@ecmwf.int'
  vendor:
    description: 'Package vendor name'
    required: false
    default: 'ECMWF'
  homepage_url:
    description: 'Project homepage URL. Falls back to GitHub repository URL.'
    required: false
    default: ''
  install_prefix:
    description: 'Package installation prefix (e.g. /opt/ecmwf)'
    required: false
    default: '/opt/ecmwf'
  self_test:
    description: 'Run tests after build before packaging'
    required: false
    default: 'true'
  install_test:
    description: 'Run package installation test in Docker container'
    required: false
    default: 'false'
  install_test_os_image:
   description: 'Docker image to use for install tests'
   required: false
   default: ''
  build_type:
    description: 'CMake build type (Release, Debug, RelWithDebInfo, MinSizeRel)'
    required: false
    default: 'RelWithDebInfo'
  python_version:
    description: 'Python version for build environment'
    required: false
    default: ''
  env:
    description: 'Environment variables (VAR=value, one per line)'
    required: false
    default: ''
  deb_section:
    description: 'Debian package section (e.g. libs, science, devel)'
    required: false
    default: ''
  deb_priority:
    description: 'Debian package priority (optional, required, important, standard)'
    required: false
    default: 'optional'
  rpm_group:
    description: 'RPM package group (e.g. Development/Libraries)'
    required: false
    default: ''
  os:
    description: 'Platform OS identifier (e.g. debian-12, rocky-9.5)'
    required: true
  compiler:
    description: 'Compiler family (e.g. gnu)'
    required: false
    default: 'gnu'
  compiler_cc:
    description: 'C compiler command'
    required: false
    default: 'gcc'
  compiler_cxx:
    description: 'C++ compiler command'
    required: false
    default: 'g++'
  compiler_fc:
    description: 'Fortran compiler command'
    required: false
    default: 'gfortran'
  gh_pat:
    description: 'GitHub PAT for repo access'
    required: false
  nexus_token:
    description: 'Nexus credential (user:token)'
    required: false
  nexus_url:
    description: 'Nexus upload URL'
    required: false

outputs:
  package_path:
    description: 'Absolute path to generated package'
    value: ${{ steps.build.outputs.package_path }}

runs:
  using: composite
  steps:
    - name: Parse build configuration
      id: config
      shell: python3 {0}
      run: |
        import os

        def cmake_escape(s):
            """Escape backslashes, double-quotes, and semicolons for CMake strings."""
            return s.replace('\\', '\\\\').replace('"', '\\"').replace(';', '\\;')

        cpack_generator = '${{ inputs.cpack_generator }}'
        cpack_options = '${{ inputs.cpack_options }}'
        package_deps = '''${{ inputs.package_deps }}'''.strip()
        description = '''${{ inputs.description }}'''.strip()

        if not description:
            description = '''${{ github.event.repository.description }}'''.strip()

        license = '''${{ inputs.license }}'''.strip()
        if not license:
            license = '''${{ github.event.repository.license.spdx_id }}'''.strip()
        if license == 'NOASSERTION':
            license = ''

        maintainer = '''${{ inputs.maintainer }}'''.strip()

        vendor = '''${{ inputs.vendor }}'''.strip()

        homepage_url = '''${{ inputs.homepage_url }}'''.strip()
        if not homepage_url:
            homepage_url = 'https://github.com/${{ github.repository }}'

        install_prefix = '''${{ inputs.install_prefix }}'''.strip()

        deb_section = '''${{ inputs.deb_section }}'''.strip()
        deb_priority = '''${{ inputs.deb_priority }}'''.strip()
        rpm_group = '''${{ inputs.rpm_group }}'''.strip()

        if cpack_generator == 'DEB':
            upload_method = 'multipart'
            deps_var = 'CPACK_DEBIAN_PACKAGE_DEPENDS'
        elif cpack_generator == 'RPM':
            upload_method = 'put'
            deps_var = 'CPACK_RPM_PACKAGE_REQUIRES'
        else:
            print(f"::error::Unsupported cpack_generator: {cpack_generator}")
            raise SystemExit(1)

        overrides_cmake_file = os.path.join(os.environ['RUNNER_TEMP'], 'cpack-overrides.cmake')
        lines = []

        if package_deps:
            lines.append(f'set({deps_var} "{cmake_escape(package_deps)}" CACHE STRING "" FORCE)')
            print(f"Package deps ({deps_var}): {package_deps}")

        if description:
            escaped = cmake_escape(description)
            lines.append(f'set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "{escaped}" CACHE STRING "" FORCE)')
            print(f"Description: {description}")
        else:
            print("Description: (none)")

        if license:
            escaped_license = cmake_escape(license)
            lines.append(f'set(CPACK_RPM_PACKAGE_LICENSE "{escaped_license}" CACHE STRING "" FORCE)')
            print(f"License: {license}")
        else:
            print("License: (none)")

        # DEB-specific options
        if cpack_generator == 'DEB':
            lines.append(f'set(CPACK_DEBIAN_PACKAGE_MAINTAINER "{cmake_escape(maintainer)}" CACHE STRING "" FORCE)')
            print(f"Maintainer: {maintainer}")
            if deb_section:
                lines.append(f'set(CPACK_DEBIAN_PACKAGE_SECTION "{cmake_escape(deb_section)}" CACHE STRING "" FORCE)')
                print(f"DEB Section: {deb_section}")
            if deb_priority:
                lines.append(f'set(CPACK_DEBIAN_PACKAGE_PRIORITY "{cmake_escape(deb_priority)}" CACHE STRING "" FORCE)')
                print(f"DEB Priority: {deb_priority}")
            lines.append('set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON CACHE BOOL "" FORCE)')

        # RPM-specific options
        if cpack_generator == 'RPM':
            if rpm_group:
                lines.append(f'set(CPACK_RPM_PACKAGE_GROUP "{cmake_escape(rpm_group)}" CACHE STRING "" FORCE)')
                print(f"RPM Group: {rpm_group}")

        # Common metadata
        if vendor:
            lines.append(f'set(CPACK_PACKAGE_VENDOR "{cmake_escape(vendor)}" CACHE STRING "" FORCE)')
            lines.append(f'set(CPACK_RPM_PACKAGE_VENDOR "{cmake_escape(vendor)}" CACHE STRING "" FORCE)')
            print(f"Vendor: {vendor}")

        if homepage_url:
            lines.append(f'set(CPACK_PACKAGE_HOMEPAGE_URL "{cmake_escape(homepage_url)}" CACHE STRING "" FORCE)')
            lines.append(f'set(CPACK_RPM_PACKAGE_URL "{cmake_escape(homepage_url)}" CACHE STRING "" FORCE)')
            print(f"Homepage URL: {homepage_url}")

        if install_prefix:
            lines.append(f'set(CPACK_PACKAGING_INSTALL_PREFIX "{cmake_escape(install_prefix)}" CACHE STRING "" FORCE)')
            print(f"Install Prefix: {install_prefix}")

        with open(overrides_cmake_file, 'w') as f:
            for line in lines:
                f.write(line + '\n')

        if lines:
            print(f"Wrote overrides to {overrides_cmake_file}")
        else:
            print(f"Created empty overrides file: {overrides_cmake_file}")

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"upload_method={upload_method}\n")
            f.write(f"cpack_options={cpack_options}\n")
            f.write(f"overrides_cmake_file={overrides_cmake_file}\n")

        print(f"CPack generator: {cpack_generator}")
        print(f"Upload method: {upload_method}")
        print(f"CPack options: {cpack_options}")

    - name: Merge build package inputs
      id: merge-inputs
      shell: python3 {0}
      run: |
        import os, yaml

        merged = {
            'repository': '${{ format('{0}@{1}', github.repository, github.sha) }}',
            'cpack_generator': '${{ inputs.cpack_generator }}',
            'cpack_options': '${{ steps.config.outputs.cpack_options }}',
            'os': '${{ inputs.os }}',
            'compiler': '${{ inputs.compiler }}',
            'compiler_cc': '${{ inputs.compiler_cc }}',
            'compiler_cxx': '${{ inputs.compiler_cxx }}',
            'compiler_fc': '${{ inputs.compiler_fc }}',
            'force_build': True,
            'recreate_cache': True,
            'save_cache': False,
            'self_test': '${{ inputs.self_test }}' == 'true',
            'cmake': '${{ inputs.cmake }}',
            'ecbundle': '${{ inputs.ecbundle }}',
            'self_build': '${{ inputs.self_build }}',
            'self_coverage': '${{ inputs.self_coverage }}',
            'parallelism_factor': '${{ inputs.parallelism_factor }}',
        }

        # Add optional string fields only if non-empty.
        optional = {
            'dependencies': '''${{ inputs.dependencies }}'''.strip(),
            'dependency_branch': '''${{ inputs.dependency_branch }}'''.strip(),
            'cmake_options': '''${{ inputs.cmake_options }}'''.strip(),
            'ctest_options': '''${{ inputs.ctest_options }}'''.strip(),
            'dependency_cmake_options': '''${{ inputs.dependency_cmake_options }}'''.strip(),
            'cache_suffix': '''${{ inputs.cache_suffix }}'''.strip(),
            'toolchain_file': '''${{ inputs.toolchain_file }}'''.strip(),
            'install_dir': '''${{ inputs.install_dir }}'''.strip(),
            'download_dir': '''${{ inputs.download_dir }}'''.strip(),
            'python_version': '''${{ inputs.python_version }}'''.strip(),
            'env': '''${{ inputs.env }}'''.strip(),
        }
        for key, value in optional.items():
            if value:
                merged[key] = value

        # Add build_type to cmake_options if specified
        build_type = '''${{ inputs.build_type }}'''.strip()
        if build_type:
            existing = merged.get('cmake_options', '')
            merged['cmake_options'] = f'-DCMAKE_BUILD_TYPE={build_type} {existing}'.strip()

        # Prepend -C <file> to cmake_options so overrides (package deps,
        # description) reach cpack via the cmake cache.
        overrides_cmake_file = '${{ steps.config.outputs.overrides_cmake_file }}'
        if overrides_cmake_file:
            existing = merged.get('cmake_options', '')
            merged['cmake_options'] = f'-C {overrides_cmake_file} {existing}'.strip()

        merged_yaml = yaml.dump(merged, default_flow_style=False)

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write("build_package_inputs<<EOF\n")
            f.write(merged_yaml)
            f.write("EOF\n")

        print("Merged build_package_inputs:")
        print(merged_yaml)

    - name: Check version number
      if: ${{ inputs.skip_version_check != 'true' && inputs.dry_run != 'true' }}
      shell: python3 {0}
      run: |
        import os
        import re
        import sys

        tag = "${{ inputs.ref_name }}"

        def check_version():
            file_name = "VERSION"
            if os.path.isfile(file_name):
                with open(file_name, 'r') as f:
                    version = f.read().strip()
                    return version
            else:
                print(f"::warning::{file_name} file not found! Using {file_name} is the preferred method.")
                return

        def check_cmakelists():
            file_name = "CMakeLists.txt"
            if os.path.isfile(file_name):
                with open(file_name, 'r') as f:
                    content = f.read()
                    pattern = r"project\([\s\w]+VERSION\s+((?:\d+)(?:.\d+){0,3})"

                    hit = re.search(pattern, content)
                    version = hit.group(1)
                    return version
            else:
                print(f"::warning::{file_name} file not found!")
                return

        version = check_version() or check_cmakelists()

        if not version:
            print("::error::Version not found!")
            sys.exit(1)

        if version != tag:
            print(f"::error::Git tag ({tag}) and project version ({version}) do not match!")
            sys.exit(1)

        print("OK: Git tag and project versions match.")

    - name: Create package
      id: build
      uses: ecmwf/reusable-workflows/build-package-with-config@v2
      with:
        repository: ${{ format('{0}@{1}', github.repository, github.sha) }}
        build_package_inputs: ${{ steps.merge-inputs.outputs.build_package_inputs }}
        github_token: ${{ inputs.gh_pat || github.token }}

    - name: Verify package
      shell: bash
      run: |
        if [ -z "${{ steps.build.outputs.package_path }}" ] || [ ! -f "${{ steps.build.outputs.package_path }}" ]; then
          echo "::error::Built package not found!"
          exit 1
        fi
        echo "Package built successfully: ${{ steps.build.outputs.package_path }}"

    - name: Determine Docker image for install test
      id: docker-image
      if: ${{ inputs.install_test == 'true' }}
      shell: python3 {0}
      run: |
        import os

        os_id = '${{ inputs.os }}'

        os_to_docker = {
            'debian-11': 'debian:11',
            'debian-12': 'debian:12',
            'rocky-8.6': 'rockylinux/rockylinux:8.6',
            'rocky-9.5': 'rockylinux/rockylinux:9.5',
        }

        docker_image = "${{ inputs.install_test_os_image }}" if "${{ inputs.install_test_os_image }}" else os_to_docker.get(os_id, '')

        if docker_image:
            print(f"Mapped OS '{os_id}' to Docker image '{docker_image}'")
        else:
            print(f"::warning::No Docker image mapping for OS '{os_id}', skipping install test")

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"docker_image={docker_image}\n")

    - name: Test package installation in Docker
      if: ${{ inputs.install_test == 'true' && steps.docker-image.outputs.docker_image != '' }}
      shell: bash
      run: |
        set -euo pipefail

        package_path="${{ steps.build.outputs.package_path }}"
        package_dir="$(dirname "$package_path")"
        package_name="$(basename "$package_path")"
        docker_image="${{ steps.docker-image.outputs.docker_image }}"
        cpack_generator="${{ inputs.cpack_generator }}"

        echo "Testing package installation in Docker container"
        echo "  Image: $docker_image"
        echo "  Package: $package_name"

        if [ "$cpack_generator" == "DEB" ]; then
          install_cmd="apt-get update && apt-get install -y /pkg/$package_name"
        elif [ "$cpack_generator" == "RPM" ]; then
          install_cmd="dnf -y install epel-release && dnf install -y /pkg/$package_name"
        else
          echo "::error::Unsupported cpack_generator for install test: $cpack_generator"
          exit 1
        fi

        docker run --rm -v "$package_dir:/pkg:ro" "$docker_image" sh -c "$install_cmd"

        echo "Package installation test passed"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.run_id }}-${{ inputs.name }}
        path: ${{ steps.build.outputs.package_path }}
        if-no-files-found: error
        retention-days: 90

    - name: Upload to Nexus
      if: ${{ inputs.dry_run != 'true' }}
      shell: bash
      run: |
        token="${{ inputs.nexus_token }}"
        url="${{ inputs.nexus_url }}"

        if [ -z "$token" ] || [ -z "$url" ]; then
          echo "::warning::No Nexus token or URL provided, skipping upload"
          exit 0
        fi

        package_path="${{ steps.build.outputs.package_path }}"

        if [ "${{ steps.config.outputs.upload_method }}" == "multipart" ]; then
          response=$(curl -w "%{http_code}" --user "$token" -H "Content-Type: multipart/form-data" --data-binary "@${package_path}" "$url")
        elif [ "${{ steps.config.outputs.upload_method }}" == "put" ]; then
          file_name=$(basename "$package_path")
          response=$(curl -w "%{http_code}" --user "$token" --upload-file "${package_path}" "${url}/${file_name}")
        fi

        status=$(echo "$response" | tail -c 4)
        if [ "$status" -eq 201 ] || [ "$status" -eq 200 ]; then
          echo "Successfully uploaded!"
        else
          echo "$status: Upload failed"
          exit 1
        fi
