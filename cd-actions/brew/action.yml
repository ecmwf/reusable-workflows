name: Homebrew Formula Builder
description: Build, test, audit, and bottle a Homebrew formula

inputs:
  name:
    description: 'Build name for artifacts'
    required: true
  ref_name:
    description: 'Git ref name (tag)'
    required: true
  dry_run:
    description: 'Build only, no publish'
    required: false
    default: 'false'
  tap:
    description: 'Tap repo (e.g., ecmwf/homebrew-ecmwf)'
    required: true
  formula:
    description: 'Formula name (e.g., eckit)'
    required: true
  description:
    description: 'Formula description (auto-detected from GitHub repo if empty)'
    required: false
    default: ''
  homepage:
    description: 'Formula homepage URL (auto-detected from GitHub repo if empty)'
    required: false
    default: ''
  license:
    description: 'SPDX license identifier (auto-detected from GitHub repo if empty)'
    required: false
    default: ''
  dependencies:
    description: 'JSON-encoded dependency dict (e.g., {"cmake": ["build", "test"], "eckit": null})'
    required: false
    default: '{}'
  uses_from_macos:
    description: 'JSON-encoded list of macOS system dependencies (e.g., ["bzip2", "openssl"])'
    required: false
    default: '[]'
  install:
    description: 'Ruby code for the install block (JSON-encoded string)'
    required: false
    default: ''
  test:
    description: 'Ruby code for the test block (JSON-encoded string)'
    required: false
    default: ''
  livecheck:
    description: 'Livecheck mode: "auto" (default), "false" to disable, or JSON-encoded custom Ruby block'
    required: false
    default: 'auto'
  head:
    description: 'Ruby code for the head block (JSON-encoded string, optional)'
    required: false
    default: ''
  post_install:
    description: 'Ruby code for the post_install block (JSON-encoded string, optional)'
    required: false
    default: ''
  caveats:
    description: 'Caveats text displayed after installation (optional)'
    required: false
    default: ''
  conflicts_with:
    description: 'JSON-encoded list of conflicting formula names (optional)'
    required: false
    default: '[]'
  source_tarball_url:
    description: 'Override tarball URL (auto-generated from ref_name if empty)'
    required: false
    default: ''
  gh_pat:
    description: 'GitHub PAT for tap repo access'
    required: false
    default: ''
  build_bottle:
    description: 'Build a bottle for the current platform'
    required: false
    default: 'true'
  tap_branch:
    description: 'Target branch in tap repo (default: repo default branch)'
    required: false
    default: ''
  bottle_root_url:
    description: 'Root URL for bottle downloads'
    required: false
    default: ''

outputs:
  formula_path:
    description: 'Path to the updated formula file'
    value: ${{ steps.tap.outputs.formula_path }}
  version:
    description: 'Parsed version string'
    value: ${{ steps.config.outputs.version }}
  sha256:
    description: 'SHA256 of the source tarball'
    value: ${{ steps.config.outputs.sha256 }}

runs:
  using: composite
  steps:
    - name: Parse configuration
      id: config
      shell: python3 {0}
      run: |
        import hashlib
        import os
        import re
        import urllib.request

        ref_name = "${{ inputs.ref_name }}"
        tap = "${{ inputs.tap }}"
        formula = "${{ inputs.formula }}"
        source_tarball_url = "${{ inputs.source_tarball_url }}"
        bottle_root_url = "${{ inputs.bottle_root_url }}"

        # Auto-inject metadata with fallback to GitHub context
        description = '''${{ inputs.description }}'''.strip()
        if not description:
            description = '''${{ github.event.repository.description }}'''.strip()

        license_id = '''${{ inputs.license }}'''.strip()
        if not license_id:
            license_id = '''${{ github.event.repository.license.spdx_id }}'''.strip()
        if license_id == 'NOASSERTION':
            license_id = ''

        homepage = '''${{ inputs.homepage }}'''.strip()
        if not homepage:
            homepage = 'https://github.com/${{ github.repository }}'

        print(f"Description: {description or '(none)'}")
        print(f"License: {license_id or '(none)'}")
        print(f"Homepage: {homepage}")

        # Parse version: strip leading 'v' prefix
        version = re.sub(r'^v', '', ref_name)
        print(f"Version: {version}")

        # Parse tap org and name
        tap_parts = tap.split('/')
        tap_org = tap_parts[0]
        tap_name = tap_parts[1] if len(tap_parts) > 1 else tap_parts[0]
        print(f"Tap org: {tap_org}, Tap name: {tap_name}")

        # Construct tarball URL if not provided
        if not source_tarball_url:
            github_ref = "${{ github.ref }}"
            if github_ref.startswith("refs/tags/"):
                source_tarball_url = f"${{ github.server_url }}/${{ github.repository }}/archive/refs/tags/{ref_name}.tar.gz"
            else:
                source_tarball_url = f"${{ github.server_url }}/${{ github.repository }}/archive/${{ github.sha }}.tar.gz"
        print(f"Tarball URL: {source_tarball_url}")

        # Resolve bottle_root_url placeholders
        if bottle_root_url:
            bottle_root_url = bottle_root_url.replace('{version}', version)
        print(f"Bottle root URL: {bottle_root_url}")

        # Download tarball and compute SHA256
        print(f"Downloading tarball to compute SHA256...")
        tarball_path = os.path.join("${{ runner.temp }}", "source.tar.gz")

        req = urllib.request.Request(source_tarball_url)
        # Add PAT for private repos
        gh_pat = "${{ inputs.gh_pat }}"
        if gh_pat:
            req.add_header("Authorization", f"token {gh_pat}")

        with urllib.request.urlopen(req) as response:
            data = response.read()
            with open(tarball_path, 'wb') as f:
                f.write(data)

        sha256 = hashlib.sha256(data).hexdigest()
        print(f"SHA256: {sha256}")

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"version={version}\n")
            f.write(f"sha256={sha256}\n")
            f.write(f"tarball_url={source_tarball_url}\n")
            f.write(f"tap_org={tap_org}\n")
            f.write(f"tap_name={tap_name}\n")
            f.write(f"bottle_root_url={bottle_root_url}\n")
            f.write(f"description={description}\n")
            f.write(f"homepage={homepage}\n")
            f.write(f"license={license_id}\n")

    - name: Check dry run mode
      if: ${{ inputs.dry_run == 'true' }}
      shell: bash
      run: |
        echo "::notice::Dry run mode: build and test only, publishing will be skipped by the workflow."

    - name: Generate desired formula
      shell: bash
      run: |
        desired_path="${{ runner.temp }}/desired-formula.rb"

        python3 "${{ github.action_path }}/scripts/generate_formula.py" \
          --formula-name "${{ inputs.formula }}" \
          --url "${{ steps.config.outputs.tarball_url }}" \
          --sha256 "${{ steps.config.outputs.sha256 }}" \
          --version "${{ steps.config.outputs.version }}" \
          --desc "${{ steps.config.outputs.description }}" \
          --homepage "${{ steps.config.outputs.homepage }}" \
          --license "${{ steps.config.outputs.license }}" \
          --dependencies-json '${{ inputs.dependencies }}' \
          --uses-from-macos-json '${{ inputs.uses_from_macos }}' \
          --install-json '${{ inputs.install }}' \
          --test-json '${{ inputs.test }}' \
          --livecheck '${{ inputs.livecheck }}' \
          --head-json '${{ inputs.head }}' \
          --post-install-json '${{ inputs.post_install }}' \
          --caveats '${{ inputs.caveats }}' \
          --conflicts-json '${{ inputs.conflicts_with }}' \
          --output "$desired_path"

        echo "Generated desired formula:"
        cat "$desired_path"

    - name: Tap and install formula
      id: tap
      shell: bash
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"
        gh_pat="${{ inputs.gh_pat }}"
        tap_branch="${{ inputs.tap_branch }}"

        # Set up auth for private taps
        if [ -n "$gh_pat" ]; then
          git config --global url."https://x-access-token:${gh_pat}@github.com/".insteadOf "https://github.com/"
        fi

        # Tap from remote (gets dependency formulae like ecbuild)
        brew tap "${tap_org}/${tap_name}"

        if [ -n "$tap_branch" ]; then
          tap_dir="$(brew --repository)/Library/Taps/${tap_org}/${tap_name}"
          git -C "$tap_dir" fetch origin "$tap_branch"
          git -C "$tap_dir" checkout "$tap_branch"
        fi

        # Clean up git auth
        if [ -n "$gh_pat" ]; then
          git config --global --unset url."https://x-access-token:${gh_pat}@github.com/".insteadOf || true
        fi

        # Drop in the generated formula
        tap_dir="$(brew --repository)/Library/Taps/${tap_org}/${tap_name}"
        formula_path="${tap_dir}/Formula/${formula}.rb"
        mkdir -p "$(dirname "$formula_path")"
        cp "${{ runner.temp }}/desired-formula.rb" "$formula_path"

        echo "formula_path=${formula_path}" >> "$GITHUB_OUTPUT"
        echo "Installed formula:"
        cat "$formula_path"

    - name: Use local tarball for private repos
      if: ${{ inputs.gh_pat != '' }}
      shell: bash
      run: |
        formula_path="${{ steps.tap.outputs.formula_path }}"
        tarball_path="${{ runner.temp }}/source.tar.gz"

        python3 -c "
        import re, sys
        with open('${formula_path}', 'r') as f:
            content = f.read()
        content = re.sub(r'url \"https://[^\"]+\"', 'url \"file://${tarball_path}\"', content, count=1)
        with open('${formula_path}', 'w') as f:
            f.write(content)
        "

        echo "Formula URL replaced with local tarball for build:"
        grep 'url "' "$formula_path"

    - name: Install from source
      shell: bash
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"

        echo "Installing ${tap_org}/${tap_name}/${formula} from source..."
        brew install --build-from-source "${tap_org}/${tap_name}/${formula}"

        echo "Installation complete"

    - name: Run tests
      shell: bash
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"

        echo "Running brew test for ${formula}..."
        brew test "${tap_org}/${tap_name}/${formula}"

        echo "Tests passed"

    - name: Run audit
      id: audit
      shell: bash
      continue-on-error: true
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"

        echo "Running brew audit for ${formula}..."
        brew audit --strict "${tap_org}/${tap_name}/${formula}"

    - name: Report audit result
      if: ${{ steps.audit.outcome == 'failure' }}
      shell: bash
      run: |
        echo "::warning::brew audit --strict failed. Review audit output above for issues."

    - name: Build bottle
      if: ${{ inputs.build_bottle == 'true' }}
      id: bottle
      shell: bash
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"
        bottle_root_url="${{ steps.config.outputs.bottle_root_url }}"
        bottle_dir="${{ runner.temp }}/bottles"

        mkdir -p "$bottle_dir"
        cd "$bottle_dir"

        echo "Reinstalling ${formula} in bottle mode..."
        brew reinstall --build-bottle "${tap_org}/${tap_name}/${formula}"

        echo "Building bottle..."
        root_url_arg=""
        if [ -n "$bottle_root_url" ]; then
          root_url_arg="--root-url=${bottle_root_url}"
        fi

        brew bottle --json ${root_url_arg} "${tap_org}/${tap_name}/${formula}"

        echo "Bottle files:"
        ls -la "$bottle_dir"

        echo "bottle_dir=$bottle_dir" >> $GITHUB_OUTPUT

    - name: Restore formula URL
      if: ${{ inputs.gh_pat != '' }}
      shell: bash
      run: |
        # Restore the real remote URL for the published formula
        cp "${{ runner.temp }}/desired-formula.rb" "${{ steps.tap.outputs.formula_path }}"
        echo "Formula URL restored for publishing:"
        grep 'url "' "${{ steps.tap.outputs.formula_path }}"

    - name: Upload artifacts
      if: ${{ inputs.build_bottle == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.run_id }}-${{ inputs.name }}
        path: |
          ${{ steps.bottle.outputs.bottle_dir }}/*.tar.gz
          ${{ steps.bottle.outputs.bottle_dir }}/*.json
          ${{ steps.tap.outputs.formula_path }}
        if-no-files-found: error
        retention-days: 90

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        tap_org="${{ steps.config.outputs.tap_org }}"
        tap_name="${{ steps.config.outputs.tap_name }}"
        formula="${{ inputs.formula }}"

        echo "Cleaning up..."
        brew uninstall "$formula" 2>/dev/null || true
        brew untap "${tap_org}/${tap_name}" 2>/dev/null || true
        rm -rf "${{ runner.temp }}/bottles"
        echo "Cleanup complete"
