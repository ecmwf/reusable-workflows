name: HPC Module Deployer
description: Build and deploy HPC modules with support for multi-stage builds and custom install commands

inputs:
  # Standard CD inputs
  name:
    description: 'Build name for identification'
    required: true
  ref_name:
    description: 'Git ref name for deployment'
    required: true
  dry_run:
    description: 'Dry run mode - build on HPC but skip module sync'
    required: false
    default: 'false'

  # HPC Authentication
  github_user:
    description: 'GitHub user for authentication'
    required: true
  github_token:
    description: 'GitHub PAT for repository access'
    required: true
  troika_user:
    description: 'HPC submission user'
    required: true

  # Compiler/Platform
  platform:
    description: 'Compiler platform (gnu-12.2.0, gnu-8.5.0, nvidia-22.11, intel-2021.4.0)'
    required: true

  # Installation
  install_type:
    description: 'Install type: module (to /usr/local/apps), perm (persistent), temp (temporary)'
    required: false
    default: 'module'
  install_prefix:
    description: 'Custom install prefix (overrides install_type default path)'
    required: false
    default: ''
  prefix_compiler_specific:
    description: 'Suffix <compiler>/<version> to install prefix'
    required: false
    default: 'false'

  # Build Configuration
  cmake_options:
    description: 'CMake/ecbuild options (comma-separated, e.g., -DENABLE_TESTS=ON,-DCMAKE_BUILD_TYPE=Release)'
    required: false
    default: ''
  ctest_options:
    description: 'CTest options for testing'
    required: false
    default: ''
  self_test:
    description: 'Run tests after building'
    required: false
    default: 'true'
  env_vars:
    description: 'Environment variables (JSON object, e.g., {"CTEST_PARALLEL_LEVEL": "4"})'
    required: false
    default: ''
  parallel:
    description: 'Number of parallel build jobs'
    required: false
    default: ''
  use_ninja:
    description: 'Use ninja build system instead of make'
    required: false
    default: 'true'

  # Dependencies
  dependencies:
    description: 'Build dependencies (owner/repo@ref format, one per line)'
    required: false
    default: ''
  dependency_cmake_options:
    description: 'CMake options for dependencies (YAML format: "owner/repo: -DOPTION=VALUE")'
    required: false
    default: ''
  python_dependencies:
    description: 'Python dependencies to build from source (owner/repo@ref format, one per line)'
    required: false
    default: ''
  python_version:
    description: 'Python version to use for build'
    required: false
    default: ''
  python_requirements:
    description: 'Path to pip requirements file for python packages'
    required: false
    default: ''
  python_toml_opt_dep_sections:
    description: 'List of optional dependency sections specified in pyproject.toml'
    required: false
    default: ''
  conda_deps:
    description: 'Conda packages to install'
    required: false
    default: ''

  # Stage Configuration (for multi-stage builds)
  stages:
    description: |
      JSON array of build stages for multi-Python or multi-config builds.
      Each stage object can have:
        - name: Stage identifier (required)
        - modules: Array of modules to load for this stage
        - cmake_options: CMake options for this stage (e.g., Boost/Python paths)
        - build_command: Custom build command (default: make -j$PARALLEL)
        - test_command: Optional test command to run before install (e.g., ctest --output-on-failure -j 8)
        - install_command: Custom install command (default: cmake --install .)
      Example: [{"name":"py312","modules":["python3/3.12","boost/1.87"],"cmake_options":"-DPython3_ROOT=...","test_command":"ctest --output-on-failure -j 8"}]
    required: false
    default: ''

  # Single-stage options (used when stages not provided)
  modules:
    description: 'Modules to load (JSON array or newline-separated, e.g., ["python/3.12", "boost/1.87"])'
    required: false
    default: ''
  install_command:
    description: 'Custom install command (overrides default cmake --install). Use $INSTALL_PREFIX for install path.'
    required: false
    default: ''

  # Finalization
  lock_permissions:
    description: 'Lock install directory permissions after build (chmod a-w)'
    required: false
    default: 'true'
  sync_module:
    description: 'Sync module to other clusters after build'
    required: false
    default: 'true'
  module_name:
    description: 'Module name for sync (if different from repo name)'
    required: false
    default: ''

  # Resource Options
  ntasks:
    description: 'Number of tasks for the job'
    required: false
    default: ''
  gpus:
    description: 'Number of GPUs required'
    required: false
    default: ''
  queue:
    description: 'HPC queue (nf, ng, deploy)'
    required: false
    default: ''

  # Advanced Options
  site:
    description: 'HPC site name'
    required: false
    default: 'hpc-batch'
  workdir:
    description: 'Work directory on HPC'
    required: false
    default: ''
  output_dir:
    description: 'Output directory on HPC'
    required: false
    default: ''
  post_script:
    description: 'Bash script to run after build (path relative to repo root)'
    required: false
    default: ''
  clean_before_install:
    description: 'Remove existing install directory before install (for nightly builds)'
    required: false
    default: 'false'
  install_lib_dir:
    description: 'CMake INSTALL_LIB_DIR value (lib or lib64). If set, adds -DINSTALL_LIB_DIR to cmake options.'
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: Parse configuration and determine build mode
      id: config
      shell: python3 {0}
      env:
        INPUT_STAGES: ${{ inputs.stages }}
      run: |
        import json
        import os
        import sys

        # Platform to compiler mapping
        platform_map = {
            'gnu-14.2.0': {
                'compiler': 'gnu-14.2.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/14.2.0'
            },
            'gnu-12.2.0': {
                'compiler': 'gnu-12.2.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/12.2.0'
            },
            'gnu-8.5.0': {
                'compiler': 'gnu-8.5.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/8.5.0'
            },
            'nvidia-22.11': {
                'compiler': 'nvidia-22.11',
                'compiler_cc': 'nvc',
                'compiler_cxx': 'nvc++',
                'compiler_fc': 'nvfortran',
                'compiler_modules': 'prgenv/nvidia,nvidia/22.11'
            },
            'intel-2021.4.0': {
                'compiler': 'intel-2021.4.0',
                'compiler_cc': 'icc',
                'compiler_cxx': 'icpc',
                'compiler_fc': 'ifort',
                'compiler_modules': 'prgenv/intel,intel/2021.4.0'
            }
        }

        platform = "${{ inputs.platform }}"
        if platform not in platform_map:
            print(f"::error::Unknown platform '{platform}'")
            print(f"Available platforms: {', '.join(platform_map.keys())}")
            sys.exit(1)

        compiler_info = platform_map[platform]

        # Determine build mode
        # Use environment variable for stages to avoid JSON parsing issues with newlines
        stages_input = os.environ.get('INPUT_STAGES', '').strip()
        install_command = '''${{ inputs.install_command }}'''.strip()
        dry_run = '${{ inputs.dry_run }}' == 'true'
        sync_module_input = '${{ inputs.sync_module }}' == 'true'

        do_sync = not dry_run and sync_module_input

        install_prefix_input = '''${{ inputs.install_prefix }}'''.strip()
        install_type = '${{ inputs.install_type }}'
        module_name = '''${{ inputs.module_name }}'''.strip() or '${{ github.repository }}'.split('/')[-1]
        ref_name = '${{ inputs.ref_name }}'
        prefix_compiler_specific = '${{ inputs.prefix_compiler_specific }}' == 'true'

        if install_prefix_input:
            install_prefix = install_prefix_input
        elif install_type == 'module':
            install_prefix = f'/usr/local/apps/{module_name}/{ref_name}'
        else:
            install_prefix = '$' + '{TMPDIR}' + f'/install/{module_name}/{ref_name}'

        if prefix_compiler_specific:
            install_prefix = f"{install_prefix}/{compiler_info['compiler']}"

        if stages_input:
            mode = 'multi-stage'
            use_generic = True
            try:
                stages = json.loads(stages_input)
            except json.JSONDecodeError as e:
                print(f"::error::Failed to parse stages JSON: {e}")
                print(f"Input was: {stages_input[:200]}...")
                sys.exit(1)
        else:
            mode = 'standard'
            use_generic = False
            stages = []

        # Write outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as f:
            f.write(f"mode={mode}\n")
            f.write(f"use_generic={'true' if use_generic else 'false'}\n")
            f.write(f"do_sync={'true' if do_sync else 'false'}\n")
            f.write(f"stages_json={json.dumps(stages)}\n")
            f.write(f"install_prefix={install_prefix}\n")
            for key, value in compiler_info.items():
                f.write(f"{key}={value}\n")

        print(f"Platform: {platform}")
        print(f"Compiler: {compiler_info['compiler']}")
        print(f"Build mode: {mode}")
        print(f"Install prefix: {install_prefix}")
        print(f"Do sync: {do_sync}")

    - name: Build with build-package-hpc (standard)
      if: steps.config.outputs.use_generic != 'true'
      shell: python3 {0}
      run: |
        import json
        import os
        import subprocess
        import sys

        # Build command arguments
        cmd = ['poetry', 'run', 'python', '-m', 'build_package_hpc', 'build']

        # Required arguments
        cmd.append(f'--package=${{ github.repository }}@${{ inputs.ref_name }}')
        cmd.append(f'--github-user=${{ inputs.github_user }}')
        cmd.append(f'--github-token=${{ inputs.github_token }}')
        cmd.append(f'--troika-user=${{ inputs.troika_user }}')
        cmd.append(f'--compiler=${{ steps.config.outputs.compiler }}')
        cmd.append(f'--compiler-cc=${{ steps.config.outputs.compiler_cc }}')
        cmd.append(f'--compiler-cxx=${{ steps.config.outputs.compiler_cxx }}')
        cmd.append(f'--compiler-fc=${{ steps.config.outputs.compiler_fc }}')
        cmd.append(f'--compiler-modules=${{ steps.config.outputs.compiler_modules }}')
        cmd.append(f'--site=${{ inputs.site }}')
        cmd.append(f'--install-type=${{ inputs.install_type }}')
        cmd.append(f'--sync-module=${{ steps.config.outputs.do_sync }}')
        cmd.append(f'--self-test=${{ inputs.self_test }}')

        # Optional arguments - only add if non-empty
        def add_if_set(flag, value):
            if value and value.strip():
                cmd.append(f'{flag}={value}')

        def add_bool_if_true(flag, value):
            if value == 'true':
                cmd.append(f'{flag}=true')

        add_if_set('--install-prefix', '''${{ inputs.install_prefix }}'''.strip())
        add_bool_if_true('--prefix-compiler-specific', '${{ inputs.prefix_compiler_specific }}')
        add_if_set('--cmake-options', '''${{ inputs.cmake_options }}'''.strip())
        add_if_set('--ctest-options', '''${{ inputs.ctest_options }}'''.strip())
        add_if_set('--module-name', '''${{ inputs.module_name }}'''.strip())
        add_if_set('--parallel', '''${{ inputs.parallel }}'''.strip())
        add_if_set('--ntasks', '''${{ inputs.ntasks }}'''.strip())
        add_if_set('--gpus', '''${{ inputs.gpus }}'''.strip())
        add_if_set('--queue', '''${{ inputs.queue }}'''.strip())
        add_if_set('--workdir', '''${{ inputs.workdir }}'''.strip())
        add_if_set('--output-dir', '''${{ inputs.output_dir }}'''.strip())
        add_if_set('--post-script', '''${{ inputs.post_script }}'''.strip())
        add_bool_if_true('--clean-before-install', '${{ inputs.clean_before_install }}')

        # Dependencies (convert newlines to commas)
        deps = ','.join('''${{ inputs.dependencies }}'''.strip().splitlines())
        if deps:
            cmd.append(f'--dependencies={deps}')

        py_deps = ','.join('''${{ inputs.python_dependencies }}'''.strip().splitlines())
        if py_deps:
            cmd.append(f'--python-dependencies={py_deps}')

        add_if_set('--python', '''${{ inputs.python_version }}'''.strip())
        add_if_set('--requirements', '''${{ inputs.python_requirements }}'''.strip())
        add_if_set('--toml-opt-dep-sections', '''${{ inputs.python_toml_opt_dep_sections }}'''.strip())

        conda_deps = '''${{ inputs.conda_deps }}'''.strip()
        if conda_deps:
            cmd.append(f'--conda-deps={conda_deps}')

        dep_cmake = '''${{ inputs.dependency_cmake_options }}'''.strip()
        if dep_cmake:
            cmd.append(f'--dependency-cmake-options={dep_cmake}')

        # Modules
        modules_input = '''${{ inputs.modules }}'''.strip()
        if modules_input:
            try:
                modules = json.loads(modules_input)
                if modules:
                    cmd.append(f'--modules={",".join(modules)}')
            except json.JSONDecodeError:
                # Try as newline/comma-separated
                modules = [m.strip() for m in modules_input.replace('\n', ',').split(',') if m.strip()]
                if modules:
                    cmd.append(f'--modules={",".join(modules)}')

        # Environment variables
        env_input = '''${{ inputs.env_vars }}'''.strip()
        if env_input:
            try:
                env_dict = json.loads(env_input)
                for k, v in env_dict.items():
                    cmd.append(f'--env={k}={v}')
            except json.JSONDecodeError:
                print(f"::warning::Could not parse env_vars as JSON: {env_input}")

        # Run the command
        os.chdir(os.path.expanduser('~/build-package-hpc'))

        # Remove any existing cancel script
        cancel_script = 'cancel-job.sh'
        if os.path.exists(cancel_script):
            os.remove(cancel_script)

        print("Running command:")
        print(' '.join(cmd))
        print()

        result = subprocess.run(cmd)
        sys.exit(result.returncode)

    - name: Cancel HPC job
      if: cancelled() && steps.config.outputs.use_generic != 'true'
      shell: bash
      run: |
        cd ~/build-package-hpc
        if [ -f "cancel-job.sh" ]; then
            bash cancel-job.sh
        else
          echo "Job cancel script not found!"
        fi

    - name: Generate build template
      if: steps.config.outputs.use_generic == 'true'
      id: template
      shell: python3 {0}
      env:
        INPUT_STAGES: ${{ inputs.stages }}
        INPUT_CMAKE_OPTIONS: ${{ inputs.cmake_options }}
        INPUT_DEPENDENCIES: ${{ inputs.dependencies }}
        INPUT_INSTALL_LIB_DIR: ${{ inputs.install_lib_dir }}
      run: |
        import json
        import os
        from pathlib import Path
        from jinja2 import Environment, FileSystemLoader

        # Load Jinja templates
        action_dir = Path('${{ github.action_path }}')
        template_dir = action_dir / 'templates'
        env = Environment(
            loader=FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True,
        )
        template = env.get_template('build-job.jinja')

        # Parse inputs from environment variables
        stages = json.loads(os.environ.get('INPUT_STAGES', '[]'))
        base_cmake_options = os.environ.get('INPUT_CMAKE_OPTIONS', '').strip()
        dependencies_input = os.environ.get('INPUT_DEPENDENCIES', '').strip()
        install_lib_dir = os.environ.get('INPUT_INSTALL_LIB_DIR', '').strip()

        if install_lib_dir:
            base_cmake_options = f'-DINSTALL_LIB_DIR={install_lib_dir} {base_cmake_options}'.strip()

        repository = '${{ github.repository }}'
        repo_name = repository.split('/')[-1]
        ref_name = '${{ inputs.ref_name }}'
        compiler_modules = '${{ steps.config.outputs.compiler_modules }}'
        module_name = '''${{ inputs.module_name }}'''.strip() or repo_name
        parallel = '''${{ inputs.parallel }}'''.strip() or '64'
        do_sync = '${{ steps.config.outputs.do_sync }}' == 'true'
        lock_permissions = '${{ inputs.lock_permissions }}' == 'true'
        use_ninja = '${{ inputs.use_ninja }}' == 'true'

        if use_ninja:
            generator = '-GNinja'
            build_cmd = 'ninja'
        else:
            generator = ''
            build_cmd = 'make'

        # Parse dependencies
        deps = []
        for dep in dependencies_input.splitlines():
            dep = dep.strip()
            if not dep:
                continue
            if '@' in dep:
                dep_repo, dep_ref = dep.rsplit('@', 1)
            else:
                dep_repo, dep_ref = dep, 'main'
            dep_name = dep_repo.split('/')[-1]
            deps.append({'repo': dep_repo, 'ref': dep_ref, 'name': dep_name})

        # Normalize stages to ensure required fields
        for i, stage in enumerate(stages):
            stage.setdefault('name', f'stage-{i}')
            stage.setdefault('modules', [])
            stage.setdefault('cmake_options', '')
            stage.setdefault('build_command', '')
            stage.setdefault('test_command', '')
            stage.setdefault('install_command', '')

        # Render template
        rendered = template.render(
            repository=repository,
            repo_name=repo_name,
            ref_name=ref_name,
            compiler_modules=compiler_modules,
            use_ninja=use_ninja,
            parallel=parallel,
            dependencies=deps,
            stages=stages,
            base_cmake_options=base_cmake_options,
            build_cmd=build_cmd,
            generator=generator,
            lock_permissions=lock_permissions,
            do_sync=do_sync,
            module_name=module_name,
        )

        # Generate sbatch options using the macro from macros.jinja
        site = '${{ inputs.site }}'
        queue = '''${{ inputs.queue }}'''.strip() or 'nf'
        ntasks = '''${{ inputs.ntasks }}'''.strip() or '1'
        gpus = '''${{ inputs.gpus }}'''.strip()

        sbatch_template = env.from_string(
            "{% from 'macros.jinja' import sbatch_options with context %}{{ sbatch_options() }}"
        )
        sbatch = sbatch_template.render(
            site=site,
            queue=queue,
            ntasks=ntasks,
            parallel=parallel,
            gpus=gpus,
        ).strip()

        # Write outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as f:
            f.write("template<<EOF\n")
            f.write(rendered)
            f.write("\nEOF\n")
            f.write("sbatch_options<<SBATCH_EOF\n")
            f.write(sbatch)
            f.write("\nSBATCH_EOF\n")

        print("Generated template:")
        print(rendered)
        print("\nSBATCH options:")
        print(sbatch)

    - name: Build with ci-hpc-generic (custom/multi-stage)
      if: steps.config.outputs.use_generic == 'true'
      uses: ecmwf/reusable-workflows/ci-hpc-generic@v2
      with:
        troika_user: ${{ inputs.troika_user }}
        site: ${{ inputs.site }}
        workdir: ${{ inputs.workdir }}
        output_dir: ${{ inputs.output_dir }}
        template: ${{ steps.template.outputs.template }}
        sbatch_options: ${{ steps.template.outputs.sbatch_options }}
        template_data: |
          github_user: ${{ inputs.github_user }}
          github_token: ${{ inputs.github_token }}
          install_prefix: ${{ steps.config.outputs.install_prefix }}
