name: HPC Module Deployer
description: Build and deploy HPC modules with support for multi-stage builds and custom install commands

inputs:
  # Standard CD inputs
  name:
    description: 'Build name for identification'
    required: true
  ref_name:
    description: 'Git ref name for deployment'
    required: true
  dry_run:
    description: 'Dry run mode - build on HPC but skip module sync'
    required: false
    default: 'false'

  # HPC Authentication
  github_user:
    description: 'GitHub user for authentication'
    required: true
  github_token:
    description: 'GitHub PAT for repository access'
    required: true
  troika_user:
    description: 'HPC submission user'
    required: true

  # Compiler/Platform
  platform:
    description: 'Compiler platform (gnu-12.2.0, gnu-8.5.0, nvidia-22.11, intel-2021.4.0)'
    required: true

  # Installation
  install_type:
    description: 'Install type: module (to /usr/local/apps), perm (persistent), temp (temporary)'
    required: false
    default: 'module'
  install_prefix:
    description: 'Custom install prefix (overrides install_type default path)'
    required: false
    default: ''
  prefix_compiler_specific:
    description: 'Suffix <compiler>/<version> to install prefix'
    required: false
    default: 'false'

  # Build Configuration
  cmake_options:
    description: 'CMake/ecbuild options (comma-separated, e.g., -DENABLE_TESTS=ON,-DCMAKE_BUILD_TYPE=Release)'
    required: false
    default: ''
  ctest_options:
    description: 'CTest options for testing'
    required: false
    default: ''
  self_test:
    description: 'Run tests after building'
    required: false
    default: 'true'
  env_vars:
    description: 'Environment variables (JSON object, e.g., {"CTEST_PARALLEL_LEVEL": "4"})'
    required: false
    default: ''
  parallel:
    description: 'Number of parallel build jobs'
    required: false
    default: ''
  use_ninja:
    description: 'Use ninja build system instead of make'
    required: false
    default: 'true'

  # Dependencies
  dependencies:
    description: 'Build dependencies (owner/repo@ref format, one per line)'
    required: false
    default: ''
  dependency_cmake_options:
    description: 'CMake options for dependencies (YAML format: "owner/repo: -DOPTION=VALUE")'
    required: false
    default: ''
  python_dependencies:
    description: 'Python dependencies to build from source (owner/repo@ref format, one per line)'
    required: false
    default: ''
  python_version:
    description: 'Python version to use for build'
    required: false
    default: ''
  python_requirements:
    description: 'Path to pip requirements file for python packages'
    required: false
    default: ''
  python_toml_opt_dep_sections:
    description: 'List of optional dependency sections specified in pyproject.toml'
    required: false
    default: ''
  conda_deps:
    description: 'Conda packages to install'
    required: false
    default: ''

  # Stage Configuration (for multi-stage builds)
  stages:
    description: |
      JSON array of build stages for multi-Python or multi-config builds.
      Each stage object can have:
        - name: Stage identifier (required)
        - modules: Array of modules to load for this stage
        - cmake_options: CMake options for this stage (e.g., Boost/Python paths)
        - build_command: Custom build command (default: make -j$PARALLEL)
        - test_command: Optional test command to run before install (e.g., ctest --output-on-failure -j 8)
        - install_command: Custom install command (default: cmake --install .)
      Example: [{"name":"py312","modules":["python3/3.12","boost/1.87"],"cmake_options":"-DPython3_ROOT=...","test_command":"ctest --output-on-failure -j 8"}]
    required: false
    default: ''

  # Single-stage options (used when stages not provided)
  modules:
    description: 'Modules to load (JSON array or newline-separated, e.g., ["python/3.12", "boost/1.87"])'
    required: false
    default: ''
  install_command:
    description: 'Custom install command (overrides default cmake --install). Use $INSTALL_PREFIX for install path.'
    required: false
    default: ''

  # Finalization
  lock_permissions:
    description: 'Lock install directory permissions after build (chmod a-w)'
    required: false
    default: 'true'
  sync_module:
    description: 'Sync module to other clusters after build'
    required: false
    default: 'true'
  module_name:
    description: 'Module name for sync (if different from repo name)'
    required: false
    default: ''

  # Resource Options
  ntasks:
    description: 'Number of tasks for the job'
    required: false
    default: ''
  gpus:
    description: 'Number of GPUs required'
    required: false
    default: ''
  queue:
    description: 'HPC queue (nf, ng, deploy)'
    required: false
    default: ''

  # Advanced Options
  site:
    description: 'HPC site name'
    required: false
    default: 'hpc-batch'
  workdir:
    description: 'Work directory on HPC'
    required: false
    default: ''
  output_dir:
    description: 'Output directory on HPC'
    required: false
    default: ''
  post_script:
    description: 'Bash script to run after build (path relative to repo root)'
    required: false
    default: ''
  clean_before_install:
    description: 'Remove existing install directory before install (for nightly builds)'
    required: false
    default: 'false'
  install_lib_dir:
    description: 'CMake INSTALL_LIB_DIR value (lib or lib64). If set, adds -DINSTALL_LIB_DIR to cmake options.'
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: Parse configuration and determine build mode
      id: config
      shell: python3 {0}
      env:
        INPUT_STAGES: ${{ inputs.stages }}
      run: |
        import json
        import os
        import sys

        # Platform to compiler mapping
        platform_map = {
            'gnu-14.2.0': {
                'compiler': 'gnu-14.2.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/14.2.0'
            },
            'gnu-12.2.0': {
                'compiler': 'gnu-12.2.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/12.2.0'
            },
            'gnu-8.5.0': {
                'compiler': 'gnu-8.5.0',
                'compiler_cc': 'gcc',
                'compiler_cxx': 'g++',
                'compiler_fc': 'gfortran',
                'compiler_modules': 'gcc/8.5.0'
            },
            'nvidia-22.11': {
                'compiler': 'nvidia-22.11',
                'compiler_cc': 'nvc',
                'compiler_cxx': 'nvc++',
                'compiler_fc': 'nvfortran',
                'compiler_modules': 'prgenv/nvidia,nvidia/22.11'
            },
            'intel-2021.4.0': {
                'compiler': 'intel-2021.4.0',
                'compiler_cc': 'icc',
                'compiler_cxx': 'icpc',
                'compiler_fc': 'ifort',
                'compiler_modules': 'prgenv/intel,intel/2021.4.0'
            }
        }

        platform = "${{ inputs.platform }}"
        if platform not in platform_map:
            print(f"::error::Unknown platform '{platform}'")
            print(f"Available platforms: {', '.join(platform_map.keys())}")
            sys.exit(1)

        compiler_info = platform_map[platform]

        # Determine build mode
        # Use environment variable for stages to avoid JSON parsing issues with newlines
        stages_input = os.environ.get('INPUT_STAGES', '').strip()
        install_command = '''${{ inputs.install_command }}'''.strip()
        dry_run = '${{ inputs.dry_run }}' == 'true'
        sync_module_input = '${{ inputs.sync_module }}' == 'true'

        do_sync = not dry_run and sync_module_input

        install_prefix_input = '''${{ inputs.install_prefix }}'''.strip()
        install_type = '${{ inputs.install_type }}'
        module_name = '''${{ inputs.module_name }}'''.strip() or '${{ github.repository }}'.split('/')[-1]
        ref_name = '${{ inputs.ref_name }}'
        prefix_compiler_specific = '${{ inputs.prefix_compiler_specific }}' == 'true'

        if install_prefix_input:
            install_prefix = install_prefix_input
        elif install_type == 'module':
            install_prefix = f'/usr/local/apps/{module_name}/{ref_name}'
        else:
            install_prefix = '$' + '{TMPDIR}' + f'/install/{module_name}/{ref_name}'

        if prefix_compiler_specific:
            install_prefix = f"{install_prefix}/{compiler_info['compiler']}"

        if stages_input:
            mode = 'multi-stage'
            use_generic = True
            try:
                stages = json.loads(stages_input)
            except json.JSONDecodeError as e:
                print(f"::error::Failed to parse stages JSON: {e}")
                print(f"Input was: {stages_input[:200]}...")
                sys.exit(1)
        else:
            mode = 'standard'
            use_generic = False
            stages = []

        # Write outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as f:
            f.write(f"mode={mode}\n")
            f.write(f"use_generic={'true' if use_generic else 'false'}\n")
            f.write(f"do_sync={'true' if do_sync else 'false'}\n")
            f.write(f"stages_json={json.dumps(stages)}\n")
            f.write(f"install_prefix={install_prefix}\n")
            for key, value in compiler_info.items():
                f.write(f"{key}={value}\n")

        print(f"Platform: {platform}")
        print(f"Compiler: {compiler_info['compiler']}")
        print(f"Build mode: {mode}")
        print(f"Install prefix: {install_prefix}")
        print(f"Do sync: {do_sync}")

    - name: Build with build-package-hpc (standard)
      if: steps.config.outputs.use_generic != 'true'
      shell: python3 {0}
      run: |
        import json
        import os
        import subprocess
        import sys

        # Build command arguments
        cmd = ['poetry', 'run', 'python', '-m', 'build_package_hpc', 'build']

        # Required arguments
        cmd.append(f'--package=${{ github.repository }}@${{ inputs.ref_name }}')
        cmd.append(f'--github-user=${{ inputs.github_user }}')
        cmd.append(f'--github-token=${{ inputs.github_token }}')
        cmd.append(f'--troika-user=${{ inputs.troika_user }}')
        cmd.append(f'--compiler=${{ steps.config.outputs.compiler }}')
        cmd.append(f'--compiler-cc=${{ steps.config.outputs.compiler_cc }}')
        cmd.append(f'--compiler-cxx=${{ steps.config.outputs.compiler_cxx }}')
        cmd.append(f'--compiler-fc=${{ steps.config.outputs.compiler_fc }}')
        cmd.append(f'--compiler-modules=${{ steps.config.outputs.compiler_modules }}')
        cmd.append(f'--site=${{ inputs.site }}')
        cmd.append(f'--install-type=${{ inputs.install_type }}')
        cmd.append(f'--sync-module=${{ steps.config.outputs.do_sync }}')
        cmd.append(f'--self-test=${{ inputs.self_test }}')

        # Optional arguments - only add if non-empty
        def add_if_set(flag, value):
            if value and value.strip():
                cmd.append(f'{flag}={value}')

        def add_bool_if_true(flag, value):
            if value == 'true':
                cmd.append(f'{flag}=true')

        add_if_set('--install-prefix', '''${{ inputs.install_prefix }}'''.strip())
        add_bool_if_true('--prefix-compiler-specific', '${{ inputs.prefix_compiler_specific }}')
        add_if_set('--cmake-options', '''${{ inputs.cmake_options }}'''.strip())
        add_if_set('--ctest-options', '''${{ inputs.ctest_options }}'''.strip())
        add_if_set('--module-name', '''${{ inputs.module_name }}'''.strip())
        add_if_set('--parallel', '''${{ inputs.parallel }}'''.strip())
        add_if_set('--ntasks', '''${{ inputs.ntasks }}'''.strip())
        add_if_set('--gpus', '''${{ inputs.gpus }}'''.strip())
        add_if_set('--queue', '''${{ inputs.queue }}'''.strip())
        add_if_set('--workdir', '''${{ inputs.workdir }}'''.strip())
        add_if_set('--output-dir', '''${{ inputs.output_dir }}'''.strip())
        add_if_set('--post-script', '''${{ inputs.post_script }}'''.strip())
        add_bool_if_true('--clean-before-install', '${{ inputs.clean_before_install }}')

        # Dependencies (convert newlines to commas)
        deps = ','.join('''${{ inputs.dependencies }}'''.strip().splitlines())
        if deps:
            cmd.append(f'--dependencies={deps}')

        py_deps = ','.join('''${{ inputs.python_dependencies }}'''.strip().splitlines())
        if py_deps:
            cmd.append(f'--python-dependencies={py_deps}')

        add_if_set('--python', '''${{ inputs.python_version }}'''.strip())
        add_if_set('--requirements', '''${{ inputs.python_requirements }}'''.strip())
        add_if_set('--toml-opt-dep-sections', '''${{ inputs.python_toml_opt_dep_sections }}'''.strip())

        conda_deps = '''${{ inputs.conda_deps }}'''.strip()
        if conda_deps:
            cmd.append(f'--conda-deps={conda_deps}')

        dep_cmake = '''${{ inputs.dependency_cmake_options }}'''.strip()
        if dep_cmake:
            cmd.append(f'--dependency-cmake-options={dep_cmake}')

        # Modules
        modules_input = '''${{ inputs.modules }}'''.strip()
        if modules_input:
            try:
                modules = json.loads(modules_input)
                if modules:
                    cmd.append(f'--modules={",".join(modules)}')
            except json.JSONDecodeError:
                # Try as newline/comma-separated
                modules = [m.strip() for m in modules_input.replace('\n', ',').split(',') if m.strip()]
                if modules:
                    cmd.append(f'--modules={",".join(modules)}')

        # Environment variables
        env_input = '''${{ inputs.env_vars }}'''.strip()
        if env_input:
            try:
                env_dict = json.loads(env_input)
                for k, v in env_dict.items():
                    cmd.append(f'--env={k}={v}')
            except json.JSONDecodeError:
                print(f"::warning::Could not parse env_vars as JSON: {env_input}")

        # Run the command
        os.chdir(os.path.expanduser('~/build-package-hpc'))

        # Remove any existing cancel script
        cancel_script = 'cancel-job.sh'
        if os.path.exists(cancel_script):
            os.remove(cancel_script)

        print("Running command:")
        print(' '.join(cmd))
        print()

        result = subprocess.run(cmd)
        sys.exit(result.returncode)

    - name: Cancel HPC job
      if: cancelled() && steps.config.outputs.use_generic != 'true'
      shell: bash
      run: |
        cd ~/build-package-hpc
        if [ -f "cancel-job.sh" ]; then
            bash cancel-job.sh
        else
          echo "Job cancel script not found!"
        fi

    - name: Generate build template
      if: steps.config.outputs.use_generic == 'true'
      id: template
      shell: python3 {0}
      env:
        INPUT_STAGES: ${{ inputs.stages }}
        INPUT_CMAKE_OPTIONS: ${{ inputs.cmake_options }}
        INPUT_DEPENDENCIES: ${{ inputs.dependencies }}
        INPUT_INSTALL_LIB_DIR: ${{ inputs.install_lib_dir }}
      run: |
        import json
        import os

        stages = json.loads(os.environ.get('INPUT_STAGES', '[]'))
        base_cmake_options = os.environ.get('INPUT_CMAKE_OPTIONS', '').strip()
        dependencies_input = os.environ.get('INPUT_DEPENDENCIES', '').strip()
        install_lib_dir = os.environ.get('INPUT_INSTALL_LIB_DIR', '').strip()

        if install_lib_dir:
            base_cmake_options = f'-DINSTALL_LIB_DIR={install_lib_dir} {base_cmake_options}'.strip()
        repository = '${{ github.repository }}'
        repo_name = repository.split('/')[-1]
        ref_name = '${{ inputs.ref_name }}'
        compiler_modules = '${{ steps.config.outputs.compiler_modules }}'
        module_name = '''${{ inputs.module_name }}'''.strip() or repo_name
        parallel = '''${{ inputs.parallel }}'''.strip() or '64'
        do_sync = '${{ steps.config.outputs.do_sync }}' == 'true'
        lock_permissions = '${{ inputs.lock_permissions }}' == 'true'
        use_ninja = '${{ inputs.use_ninja }}' == 'true'

        if use_ninja:
            generator = '-GNinja'
            build_cmd = 'ninja'
        else:
            generator = ''
            build_cmd = 'make'

        deps = [d.strip() for d in dependencies_input.splitlines() if d.strip()]

        lines = [
            f'# Multi-stage CD build for {repository}@{ref_name}',
            '',
            'INSTALL_PREFIX="{{ install_prefix }}"',
            'DEPS_PREFIX="$' + '{PWD}/deps"',
            'export INSTALL_PREFIX',
            '',
            f'module load {compiler_modules}',
        ]
        if use_ninja:
            lines.append('module load ninja')
        lines.append('')

        lines.append('# === Build Log Setup ===')
        lines.append('BUILD_LOG="${INSTALL_PREFIX}/build.log"')
        lines.append('mkdir -p "${INSTALL_PREFIX}"')
        lines.append('exec > >(tee "$BUILD_LOG") 2>&1')
        lines.append('echo "Build started: $(date -u)"')
        lines.append(f'echo "Repository: {repository}@{ref_name}"')
        lines.append('')

        if deps:
            lines.append('# === Dependencies ===')
            lines.append('mkdir -p "$DEPS_PREFIX"')
            lines.append('')

            for dep in deps:
                if '@' in dep:
                    dep_repo, dep_ref = dep.rsplit('@', 1)
                else:
                    dep_repo, dep_ref = dep, 'main'
                dep_name = dep_repo.split('/')[-1]

                lines.append(f'# {dep_name}')
                lines.append(f'git clone --depth 1 --branch "{dep_ref}" "https://{{{{ github_user }}}}:{{{{ github_token }}}}@github.com/{dep_repo}.git"')

                if dep_name == 'ecbuild':
                    # ecbuild just needs to be in PATH
                    lines.append(f'export PATH="$PWD/{dep_name}/bin:$PATH"')
                else:
                    # Build and install other deps
                    lines.append(f'mkdir -p {dep_name}/build && cd {dep_name}/build')
                    cmake_cmd = f'ecbuild --prefix="$DEPS_PREFIX" {generator} ..'.replace('  ', ' ').strip()
                    lines.append(cmake_cmd)
                    lines.append(f'{build_cmd} -j{parallel}')
                    lines.append(f'{build_cmd} install')
                    lines.append('cd ../..')

                lines.append('')

            lines.append('export CMAKE_PREFIX_PATH="$DEPS_PREFIX:$' + '{CMAKE_PREFIX_PATH:-}"')
            lines.append('export PATH="$DEPS_PREFIX/bin:$PATH"')
            lines.append('export LD_LIBRARY_PATH="$DEPS_PREFIX/lib:$' + '{LD_LIBRARY_PATH:-}"')
            lines.append('')

        lines.append('# === Main package ===')
        lines.append(f'git clone --depth 1 --branch "{ref_name}" "https://{{{{ github_user }}}}:{{{{ github_token }}}}@github.com/{repository}.git"')
        lines.append(f'cd {repo_name}')
        lines.append('mkdir -p build && cd build')
        lines.append('')

        for i, stage in enumerate(stages):
            name = stage.get('name', f'stage-{i}')
            modules = stage.get('modules', [])
            cmake_opts = stage.get('cmake_options', '')
            build_command = stage.get('build_command', '')
            test_command = stage.get('test_command', '')
            install_cmd = stage.get('install_command', '')

            lines.append(f'echo "=== Stage: {name} ==="')

            # Load stage modules
            for mod in modules:
                lines.append(f'module load {mod}')

            if i == 0 or cmake_opts:
                if i > 0:
                    lines.append('cd .. && rm -rf build && mkdir build && cd build')
                opts = f'{base_cmake_options} {cmake_opts}'.strip()
                cmake_line = f'cmake .. {generator} -DCMAKE_INSTALL_PREFIX="$' + '{INSTALL_PREFIX}" ' + opts
                lines.append(cmake_line.replace('  ', ' ').strip())

            if build_command:
                lines.append(build_command)
            else:
                lines.append(f'{build_cmd} -j{parallel}')

            if test_command:
                lines.append(f'echo "Running tests for stage: {name}"')
                lines.append(test_command)

            # Install
            if install_cmd:
                lines.append(install_cmd)
            else:
                lines.append('cmake --install .')

            for mod in reversed(modules):
                lines.append(f'module unload {mod}')

            lines.append('')

        # Generate README.txt with package versions from build log
        lines.append('# === Generate README ===')
        lines.append('echo "Generating README.txt"')
        lines.append("python3 << 'GENERATE_README'")
        lines.append('import os')
        lines.append('import re')
        lines.append('')
        lines.append('install_prefix = os.environ.get("INSTALL_PREFIX", "")')
        lines.append('build_log = os.path.join(install_prefix, "build.log")')
        lines.append('readme_file = os.path.join(install_prefix, "README.txt")')
        lines.append('')
        lines.append('if not os.path.exists(build_log):')
        lines.append('    print("Build log not found, skipping README generation")')
        lines.append('    exit(0)')
        lines.append('')
        lines.append('with open(build_log, "r", errors="replace") as f:')
        lines.append('    log_content = f.read()')
        lines.append('')
        lines.append("# Remove ANSI color codes")
        lines.append(r"log_content = re.sub(r'\x1b\[[0-9;]*m', '', log_content)")
        lines.append('')
        lines.append('# Extract package version lines (deduplicated)')
        lines.append('seen = set()')
        lines.append('readme_lines = []')
        lines.append('current_stage = None')
        lines.append('')
        lines.append('for line in log_content.splitlines():')
        lines.append(r"    stage_match = re.match(r'^=== Stage: (.+) ===$', line)")
        lines.append('    if stage_match:')
        lines.append('        current_stage = stage_match.group(1)')
        lines.append('        continue')
        lines.append(r"    if re.match(r'^--\s+\[', line):")
        lines.append(r"        match = re.search(r'\[([^\]]+)\]', line)")
        lines.append('        if match:')
        lines.append('            package = match.group(1)')
        lines.append('            if package not in seen:')
        lines.append('                seen.add(package)')
        lines.append('                readme_lines.append(line.strip())')
        lines.append('    elif line.startswith("-- system"):')
        lines.append('        sys_line = line.strip()')
        lines.append('        if current_stage:')
        lines.append('            sys_line = sys_line.replace("-- system :", f"-- system ({current_stage}):")')
        lines.append('        readme_lines.append(sys_line)')
        lines.append('')
        lines.append('if readme_lines:')
        lines.append('    with open(readme_file, "w") as f:')
        lines.append(r'        f.write("\n".join(readme_lines) + "\n")')
        lines.append('    print(f"Generated README.txt with {len(readme_lines)} entries:")')
        lines.append(r'    print("\n".join(readme_lines))')
        lines.append('else:')
        lines.append('    print("No package version info found in build log")')
        lines.append('GENERATE_README')
        lines.append('')

        if lock_permissions:
            lines.append('chmod -R a-w "${INSTALL_PREFIX}" || true')

        if do_sync:
            lines.append('module load modulemgr')
            lines.append(f'modulemgr -v -f sync "{module_name}"')

        template = '\n'.join(lines)

        site = '${{ inputs.site }}'
        queue = '''${{ inputs.queue }}'''.strip() or 'nf'
        ntasks = '''${{ inputs.ntasks }}'''.strip() or '1'
        gpus = '''${{ inputs.gpus }}'''.strip()

        if site == 'lumi':
            sbatch_lines = [
                '#SBATCH --account=project_465000454',
                '#SBATCH --time=01:00:00',
                f'#SBATCH --ntasks={ntasks}',
                f'#SBATCH --cpus-per-task={parallel}',
                '#SBATCH --mem-per-cpu=1750',
                '#SBATCH --partition=small',
            ]
        else:
            sbatch_lines = [
                f'# TROIKA queue={queue}',
                '#SBATCH --gres=ssdtmp:30G',
                '#SBATCH --mem=64GB',
                f'#SBATCH --cpus-per-task={parallel}',
                f'#SBATCH --ntasks={ntasks}',
            ]
            if gpus:
                sbatch_lines.append(f'#SBATCH --gres=gpu:{gpus}')

        sbatch = '\n'.join(sbatch_lines)

        with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as f:
            f.write("template<<EOF\n")
            f.write(template)
            f.write("\nEOF\n")
            f.write("sbatch_options<<SBATCH_EOF\n")
            f.write(sbatch)
            f.write("\nSBATCH_EOF\n")

        print("Generated template:")
        print(template)
        print("\nSBATCH options:")
        print(sbatch)

    - name: Build with ci-hpc-generic (custom/multi-stage)
      if: steps.config.outputs.use_generic == 'true'
      uses: ecmwf/reusable-workflows/ci-hpc-generic@v2
      with:
        troika_user: ${{ inputs.troika_user }}
        site: ${{ inputs.site }}
        workdir: ${{ inputs.workdir }}
        output_dir: ${{ inputs.output_dir }}
        template: ${{ steps.template.outputs.template }}
        sbatch_options: ${{ steps.template.outputs.sbatch_options }}
        template_data: |
          github_user: ${{ inputs.github_user }}
          github_token: ${{ inputs.github_token }}
          install_prefix: ${{ steps.config.outputs.install_prefix }}
